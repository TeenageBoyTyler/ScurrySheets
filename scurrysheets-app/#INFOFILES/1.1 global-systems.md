# Global Systems & Architecture: scurrysheets

## Cloud Storage System

### Hybrid Storage Architecture
- **Primary Storage**: Google Drive remains the primary storage backend for user documents
- **Metadata & Sync**: Supabase Database for fast metadata access and synchronization
- **Temporary Storage**: Supabase Storage for processing and caching
- All user-uploaded documents stored in Google Drive
- Document metadata synced between Google Drive and Supabase Database
- OAuth authentication flows handle secure access to Google services via Supabase Auth
- Connection established via Google Drive API v3 
- **Cloud as Source of Truth**: All data stored in cloud, no local-only data

### Folder Structure
```
.scurrysheets/
├── settings.json       # User preferences and application settings (synced with Supabase)
├── documents/          # Metadata JSONs with OCR text & document tags (synced with Supabase)
├── uploads/            # Processed JPG documents/worksheets
├── thumbnails/         # Preview images for UI display (cached in Supabase Storage)
└── tags.json           # Global tag definitions and relationships (synced with Supabase)
```

### Data Security
- OAuth tokens securely managed through Supabase Authentication
- No sensitive user data stored unencrypted
- No application data stored outside the user's Google Drive and secure Supabase instance
- Document access limited to authenticated user only
- Supabase Row Level Security enforces user-specific data access
- Proper RLS policies configured for all Supabase tables

## Tag Management System

### Global Tag Architecture
- **Single Source of Truth**: Global tag collection shared across all application areas
- All user-created tags exist in a single, unified namespace
- Tags stored in `.scurrysheets/tags.json` with unique identifiers
- Tags synced with Supabase Database for real-time updates
- Each tag contains:
  - Unique ID
  - Display name
  - Color (from standard tag color palette)
  - Creation timestamp
  - Usage count (documents using tag)
- Implemented using Svelte stores for reactive state management

### Tag Synchronization
- Tag changes propagate to all documents immediately
- Supabase Realtime provides instant synchronization across devices
- Application-wide consistency enforced for all tag operations:
  - Tag creation
  - Tag renaming
  - Tag color changes
  - Tag deletion (with replacement handling)
- Changes synchronized via Svelte store subscriptions
- Supabase Realtime channels used for cross-device updates

### Tag Integrity Rules
- Every document must have at least one tag
- Tag deletion checks for orphaned documents
- System prevents document from being left without tags
- When deleting last tag on a document, user must provide replacement tag

### Implementation Principles
- Tags created in any workflow are immediately available throughout the application
- Changes to tag metadata (name, color) apply globally
- Tag usage count updated on all document operations
- See Document Flow for details on user interface implementation
- Svelte Context API used for global tag state management

## Internet Connectivity Requirements

### Connection Verification
- **At Application Start**:
  - Connectivity checked before application loads
  - Fullscreen message if offline: "Internet connection required to use scurrysheets"
  - Prevents application initialization until connection established
  - Implemented in SvelteKit root layout component
- **During Application Use**:
  - Continuous background verification of connectivity using SvelteKit Navigator API
  - Fullscreen message if connection lost: "Lost Connection" or "Not connected"
  - Application functionality completely suspended until reconnection
  - No offline functionality available
  - Automatic recovery and state restoration when connection restored

### Connection Status Indicators
- Connection status visible in profile section
- Toast messages for temporary connection issues
- Fullscreen message for startup connection requirement
- Automatic recovery when connection restored
- Implemented via Svelte stores for reactive updates

### Network Interruption Handling
- **During Upload Process**:
  - Selected files stored temporarily in Supabase Storage until successful upload or cancellation
- If connection lost during edit/tag steps, edited images are preserved via Svelte stores
- Handwriting removal requires connection, but toggle between versions works offline once processed
- All edits (crop, brightness, etc.) are persisted locally across connection interruptions
  - All-or-nothing upload approach: either all files upload successfully, or none are saved
  - For batch uploads, all files processed locally first, then uploaded to cloud in single operation
  - No partial batch upload successes
- **Clear User Communication**:
  - Fullscreen "Lost Connection" message displays when connectivity issues occur
  - Additional message: "Your changes have been lost. Please try again when connected." when appropriate
  - User returns to appropriate step based on when connection was lost

## Cross-Device Synchronization

### Synchronization Architecture
- **Hybrid Sync Strategy**:
  - Google Drive for document storage
  - Supabase Realtime for immediate metadata synchronization
- Document data syncs through Google Drive
- Metadata syncs through Supabase
- Changes from any device propagate to all devices via both cloud services

### Synchronization Process
- Changes sync automatically in background when connected
- Typical sync time under 10 seconds for metadata via Supabase Realtime
- Document sync time depends on size (via Google Drive)
- No manual sync required by user
- Silent background synchronization
- Implemented via Supabase subscriptions and Svelte stores

### Conflict Resolution
- **Hybrid Source of Truth**:
  - Google Drive for document content
  - Supabase for metadata with timestamps
- Changes from any device propagate to all other devices via cloud
- Conflict resolution uses timestamp-based approach with Supabase
- Document-level changes use timestamp-based resolution
- No local-only data exists to create conflicts

## Error Handling Guidelines

### Error Communication Principles
- All errors presented as simple toast messages
- No technical details or error codes shown to user
- Messages use plain language focused on user actions
- All messages disappear automatically after a few seconds
- Consistent tone and language across all errors
- Implemented using Svelte toast component

### Standardized Error Messages by Category

#### Authentication Errors
- "Authentication failed. Try again."
- "Google Drive access denied. Please reconnect."
- "Your session has expired. Please reconnect."

#### Connectivity Errors
- "Internet connection required to use scurrysheets." (fullscreen message at startup)
- "Lost Connection" or "Not connected" (fullscreen message during use)
- "Connection lost. Your edits are preserved locally. Reconnect to continue." (during editing)
- "Upload paused. Your processed files are saved temporarily. Click to resume upload." (during final upload)
- "Couldn't connect to Google Drive." (toast message for specific service issues)

#### Processing Errors
- "Processing failed. Try again."
- "Handwriting removal unsuccessful. Try with clearer image."
- "PDF creation failed. Try with fewer documents."

#### File Operation Errors
- "Unsupported filetype."
- "File too large. Maximum size is 10MB."
- "Storage quota exceeded on Google Drive."
- "Upload failed. Please try again when connected."

### Error Recovery Mechanisms
- Automatic retry for transient network errors (3 attempts)
- Clear user guidance for authentication issues
- Simple actionable steps for user-correctable errors
- No complex error resolution workflows
- For upload interruptions: return to appropriate step with temporarily stored files (when available)

### Error Implementation Reference
| Context | Common Errors | Handling Approach |
|---------|---------------|-------------------|
| Login Flow | Authentication, Connectivity | Simple retry button |
| Upload Flow | Filetype, Processing, Connectivity | Cancel or restart with stored files |
| Document Flow | Processing, Storage | Cancel operation with notification |
| Profile Flow | Connectivity, Authentication | Manual retry options |


## Document Processing Pipeline
*Note: This pipeline is primarily executed during the Upload Flow - more information there.*

### Format Standardization
- All allowed documents uploaded converted to standardized JPG format

### OCR Processing
- Google Cloud Vision API used for OCR extraction via user-provided API keys
- Handwriting removal capabilities using GCV AI with user's own quota
- Full text content extracted and stored in document metadata
- Text content indexed for search functionality in Supabase
- Preserves original image while storing extracted text separately
- All Vision API processing costs managed by individual users
- Real-time quota monitoring with Cloud Monitoring API
- Prevents operations that would exceed the monthly free tier (1,000 units)
- Usage dashboard in Profile section with visual indicators
- Automatic quota reset tracking on the 1st of each month
- Vision API calls handled through Supabase Edge Functions

## Metadata Structure
- Each document has associated metadata JSON file
- Metadata synced with Supabase Database for fast queries
- Metadata contains:
  - Document ID
  - Original filename
  - Upload timestamp
  - OCR text content
  - Assigned tags
  - Processing parameters
  - Image dimensions and format
  - Edit history

## Performance Optimizations

### UI Rendering
- **Virtualized Lists**: Only renders visible elements using svelte-virtual-list
- DOM element recycling during scrolling
- Optimized image loading with progressive quality
- Background prefetching of likely-to-be-viewed content
- SvelteKit SSR capabilities for improved initial load performance

### Search & Filtering
- Maintained search index in Supabase with proper indexing
- Incremental search results display
- Smart tag filtering at data source level
- Segmented data loading for large collections
- Full-text search capabilities in Supabase

### Background Processing
- Prioritized user-facing operations
- Background thumbnail generation
- Delayed synchronization for non-critical updates
- Optimized batch operations for multiple documents
- SvelteKit's SSR capabilities for improved initial load performance

## GitHub Codespaces Development

### Development Environment
- GitHub Codespaces configured for SvelteKit development
- `.devcontainer` configuration with Node.js environment
- Port forwarding for SvelteKit and Supabase local development
- VS Code extensions for Svelte, Tailwind, and ESLint

### Local Development Setup
- Supabase local development using Docker
- SvelteKit development server with HMR
- Environment variables for API keys and endpoints
- Mock data generation for testing

### Deployment Pipeline
- GitHub Actions for CI/CD
- Automated testing before deployment
- Edge Function deployment to Supabase
- Seamless deployment to hosting platform